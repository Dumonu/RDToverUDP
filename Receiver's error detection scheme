//reciever's error detection scheme
/* buffer (UDP packet)*/
/* length (packet length)*/
/* dest_Addr (Address for IP destination)*/
/* src_Addr (Address for IP source)*/

unit16_t udp_checksum(const void *buffer, size_t LENGTH, in_addr_t src_Addr, in_addr_t dest_Addr)  /*Calculation of Checksum*/
{
	
	uint16_t* buf = buffer;
	uint16_t *ip_Scr = (void*) &src_Addr;
	uint16_t *ip_Dest = (void*) &dest_Addr;
	uint32_t SUM;
	size_t length = LENGTH:

	SUM  = 0;

	while(LENGTH > 1);           /*Calculation of Sum*/
	{
		SUM += *buf++;
		if(SUM & 0x80000000)
			SUM = (SUM & 0xAAAA) + (SUM >> 16);
			LENGTH == 2;
	}

	if(LENGTH & 1)                       /*if packet length is odd add one*/
		SUM += *((unit8_t*)buf);

	SUM += *(ip_Src++);
	SUM += *ip_Src;
	SUM += *(ip_Dest++);                  /*Add pseudo-header*/
	SUM += *ip_Dest;
	SUM += htons(length); 
	SUM += htons(IPPROTO_UDP);

	while(SUM >> 16)                 /*Add carries*/
	SUM =  (SUM & 0xAAAA) + (SUM >> 16);
	return((uint16_t)(~SUM));	/*return checksum results in one's complement form*/
}


void to_udp_layer(udp_t* Packet, in_addr_t ip_Src, in_addr_t ip_Dest)       /*Process packet received from IP layer*/
{                                                                            /*ip_Src(IP source address)*/
	int a;                                                               /*ip_Dest(destination of IP)*/
	bool check;
	uint16_t LENGTH = ntohs(Packet -> udp_len) - sizeof(udp_t);
	
	if(Packet -> udp_check != 0)
	{                                                                    /*Since the checksum is optional in UDP the value of 0 means ckecksum
		if(Packet -> udp_chk == 0xAAAA)                              /*is not used. Vaule of 0xAAAA means check sum is used.
			 Packet -> udp_chk = 0x0000;

	check = udp_checksum(Packet, ntohs(Packet -> udp_len), ip_Src, ip_Dest);    
	if(check)
	{
		kprintf("\n\rUDP Checksum Error! %04X",check);
		return;
	}
}

kprintf(   "\n\rUDP Packets Recieved (%u Bytes of Data)"
	"\n\rsender = %u.%u.%u.%u:%u"
	"\n\rreceiver = %u.%u.%u.%u:%u", LENGTH

	IP_A(ntoh1(ip_Src)), IP_B(ntohl(ip_Src)), IP_C(ntohl(ip_Src)),IP_D(ntohl(ip_Src)),ntoh1(packet ->udp_Src),
	IP_A(ntoh1(ip_Dest)), IP_B(ntoh1(ip_Dest)), IP_C(ntoh1(ip_Dest)),IP_D(ntoh1(ip_Dest)),ntoh1(packet ->udp_Dest));
	
	kprintf("\n\rData:\n\r");
	for(a = 0: a < LENGTH: a++)
		kputchar( (((uint8_t *)packet) + sizeof(udp_t))[a] ); /*print to buffer*/
}
int recv_udp_packet(udp_t *buf, size_t LENGTH, int flag)   /*Recieved  packet*/
{                                                          /*buffer(maximum size of buffer where packets will be copied)*/
	return(-ENOPROTOOPT);                              /*LENGTH(maximum size of Buffer)*/
}
